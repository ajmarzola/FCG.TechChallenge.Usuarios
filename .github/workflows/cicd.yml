name: CI-CD APIUsuarios (tests → image → ACR → WebApp)

on:
  push:
    branches: [ "master" ]   # ajuste se usar main
  workflow_dispatch:
 
env:
  # --- seu ambiente Azure/ACR/WebApp ---
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  AZURE_TENANT_ID:       ${{ secrets.AZURE_TENANT_ID }}
  AZURE_CLIENT_ID:       ${{ secrets.AZURE_CLIENT_ID }}
  RESOURCE_GROUP:        fcg-usuario-rg
  WEBAPP_NAME:           FCGUsuario
  ACR_LOGIN_SERVER:      fcgusuariosconteiner-cdd9ecarc6ckf9b5.azurecr.io
  ACR_REPOSITORY:        apiusuarios

  # --- caminhos da solução e testes (pelas pastas do seu repo) ---
  SLN_PATH:              APIUsuarios/APIUsuarios.sln
  TEST_PROJECT:          APIUsuarioTeste/APIUsuarioTeste.csproj

  # --- build do Docker (Dockerfile está DENTRO de APIUsuarios) ---
  DOCKERFILE_PATH:       APIUsuarios/Dockerfile
  DOCKER_CONTEXT:        APIUsuarios

jobs:
  build_test:
    name: Build & Test (.NET 8)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET 8
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"

      - name: Restore
        run: dotnet restore "${{ env.SLN_PATH }}"

      - name: Build
        run: dotnet build "${{ env.SLN_PATH }}" -c Release --no-restore

      - name: Test
        run: dotnet test "${{ env.TEST_PROJECT }}" -c Release --no-build --logger "trx;LogFileName=test_results.trx" --collect:"XPlat Code Coverage"

      - name: Publicar resultados de teste
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            **/TestResults/*.trx
            **/TestResults/**/coverage.cobertura.xml
          if-no-files-found: ignore

  build_push_deploy:
    name: Build & Push Docker → Deploy WebApp
    runs-on: ubuntu-latest
    needs: build_test   # <<< só roda se os testes PASSAREM
    permissions:
      id-token: write   # requerido para azure/login via OIDC
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ env.AZURE_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}

      # Gera token de acesso ao ACR e faz docker login (sem salvar senha secreta)
      - name: Azure CLI - ACR Login (token efêmero)
        uses: azure/cli@v2
        with:
          inlineScript: |
            az acr login --name $(echo $ACR_LOGIN_SERVER | cut -d'.' -f1) --expose-token --output tsv --query accessToken > acr_token.txt
            echo "ACR_TOKEN=$(cat acr_token.txt)" >> $GITHUB_ENV
            echo "ACR_USERNAME=00000000-0000-0000-0000-000000000000" >> $GITHUB_ENV

      - name: Docker Login to ACR
        run: |
          echo "${{ env.ACR_TOKEN }}" | docker login ${{ env.ACR_LOGIN_SERVER }} -u ${{ env.ACR_USERNAME }} --password-stdin

      - name: Set tags
        id: vars
        run: |
          SHORT_SHA=${GITHUB_SHA::7}
          echo "TAG_SHA=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "IMAGE=${{ env.ACR_LOGIN_SERVER }}/${{ env.ACR_REPOSITORY }}:$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "IMAGE_LATEST=${{ env.ACR_LOGIN_SERVER }}/${{ env.ACR_REPOSITORY }}:latest" >> $GITHUB_OUTPUT

      - name: Build & Push (Docker) usando Dockerfile em APIUsuarios/
        run: |
          docker build -f "${{ env.DOCKERFILE_PATH }}" -t ${{ steps.vars.outputs.IMAGE }} -t ${{ steps.vars.outputs.IMAGE_LATEST }} "${{ env.DOCKER_CONTEXT }}"
          docker push ${{ steps.vars.outputs.IMAGE }}
          docker push ${{ steps.vars.outputs.IMAGE_LATEST }}

      - name: Garantir WEBSITES_PORT=8080 no WebApp
        uses: azure/cli@v2
        with:
          inlineScript: |
            az webapp config appsettings set \
              --name "${{ env.WEBAPP_NAME }}" \
              --resource-group "${{ env.RESOURCE_GROUP }}" \
              --settings WEBSITES_PORT=8080

      - name: Atualizar container do WebApp para a nova imagem
        uses: azure/cli@v2
        with:
          inlineScript: |
            az webapp config container set \
              --name "${{ env.WEBAPP_NAME }}" \
              --resource-group "${{ env.RESOURCE_GROUP }}" \
              --docker-custom-image-name "${{ steps.vars.outputs.IMAGE }}" \
              --docker-registry-server-url "https://${{ env.ACR_LOGIN_SERVER }}"
            az webapp restart --name "${{ env.WEBAPP_NAME }}" --resource-group "${{ env.RESOURCE_GROUP }}"
